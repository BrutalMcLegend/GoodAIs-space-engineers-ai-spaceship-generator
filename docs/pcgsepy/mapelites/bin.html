<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pcgsepy.mapelites.bin API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pcgsepy.mapelites.bin</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import logging
from tabnanny import check
from typing import Any, Dict, List, Optional, Tuple

import numpy as np
from pcgsepy.config import BIN_POP_SIZE, BIN_SMALLEST_PERC
from pcgsepy.lsystem.solution import CandidateSolution


class MAPBin:
    __slots__ = [&#39;_feasible&#39;, &#39;_infeasible&#39;, &#39;bin_idx&#39;, &#39;bin_size&#39;, &#39;bin_initial_size&#39;, &#39;new_elite&#39;]

    def __init__(self,
                 bin_idx: Tuple[int, int],
                 bin_size: Tuple[float, float],
                 bin_initial_size: Optional[Tuple[float, float]] = None):
        &#34;&#34;&#34;Create a 2D bin object.

        Args:
            bin_idx (Tuple[int, int]): The index of the bin in the grid.
            bin_size (Tuple[float, float]): The size of the bin.
            bin_initial_size: Optional[Tuple[float, float]]: Initial size of the bin. Defaults to None.
        &#34;&#34;&#34;
        self._feasible = []
        self._infeasible = []
        self.bin_idx = bin_idx
        self.bin_size = bin_size
        self.bin_initial_size = bin_initial_size if bin_initial_size else bin_size
        self.new_elite = {&#39;feasible&#39;: False,
                          &#39;_elite_feasible&#39;: None,
                          &#39;infeasible&#39;: False,
                          &#39;_elite_infeasible&#39;: None}

    def __str__(self) -&gt; str:
        return f&#39;Bin {self.bin_idx}, {self.bin_size} w/ {len(self._feasible)}f and {len(self._infeasible)}i cs&#39;

    def __repr__(self) -&gt; str:
        return str(self)
    
    @property
    def subdividable(self) -&gt; bool:
        &#34;&#34;&#34;Check if the bin can be subdivided. Use this method when locally increasing resolution of the behavioral map.

        Returns:
            bool: Whether the bin can be subdivided.
        &#34;&#34;&#34;
        bs0, bs1 = self.bin_size
        bis0, bis1 = self.bin_initial_size
        ms0 = bis0 * BIN_SMALLEST_PERC
        ms1 = bis1 * BIN_SMALLEST_PERC
        bs0 /= 2
        bs1 /= 2
        return bs0 &gt;= ms0 and bs1 &gt;= ms1
        
    def non_empty(self,
                  pop: str) -&gt; bool:
        &#34;&#34;&#34;Check if the bin is not empty for the given population.

        Args:
            pop (str): The population to check for.

        Returns:
            bool: Whether the bin is empty.
        &#34;&#34;&#34;
        return len(self._feasible if pop == &#39;feasible&#39; else self._infeasible) &gt; 0

    def _reduce_pop(self,
                    pop: List[CandidateSolution]) -&gt; List[CandidateSolution]:
        &#34;&#34;&#34;Cull the population within this bin.

        Args:
            pop (List[CandidateSolution]): The population.

        Returns:
            List[CandidateSolution]: The culled population.
        &#34;&#34;&#34;
        if len(pop) &gt; BIN_POP_SIZE:
            pop.sort(key=lambda x: x.c_fitness, reverse=True)
            pop = pop[:BIN_POP_SIZE]
        return pop

    def insert_cs(self,
                  cs: CandidateSolution):
        &#34;&#34;&#34;Add a solution in the bin.

        Args:
            cs (CandidateSolution): The solution to add.
        &#34;&#34;&#34;
        if cs.is_feasible:
            if cs not in self._feasible:
                self._feasible.append(cs)
                self._feasible = self._reduce_pop(self._feasible)
        else:
            if cs not in self._infeasible:
                self._infeasible.append(cs)
                self._infeasible = self._reduce_pop(self._infeasible)

    def check_new_elite(self,
                        pop: str = &#39;feasible&#39;):
        &#34;&#34;&#34;Check if the bin contains a new elite for the selected population.

        Args:
            pop (str, optional): The population. Defaults to &#39;feasible&#39;.
        &#34;&#34;&#34;
        checking = f&#39;_elite_{pop}&#39;
        elite = self.get_elite(population=pop)
        if elite is not None and (self.new_elite[checking] is None or elite.string != self.new_elite[checking].string):
            self.new_elite[pop] = True
            self.new_elite[checking] = elite
            for cs in self._feasible if pop == &#39;feasible&#39; else self._infeasible:
                if cs.string != elite.string:
                    cs._content = None
    
    def age(self,
            diff: int = -1):
        &#34;&#34;&#34;Age the bin.

        Args:
            diff (int, optional): Value used to modify the bin&#39;s age. Defaults to `-1`.
        &#34;&#34;&#34;
        for pop in [self._feasible, self._infeasible]:
            for cs in pop:
                cs.age += diff

    def remove_old(self):
        &#34;&#34;&#34;Remove old solutions. Old solutions are solutions with an age `&lt;=0`.&#34;&#34;&#34;
        to_rem_f = [x for x in self._feasible if x.age &lt;= 0]
        for cs in to_rem_f:
            self._feasible.remove(cs)
        to_rem_i = [x for x in self._infeasible if x.age &lt;= 0]
        for cs in to_rem_i:
            self._infeasible.remove(cs)

    def get_metric(self,
                   metric: str,
                   use_mean: bool = True,
                   population: str = &#39;feasible&#39;) -&gt; float:
        &#34;&#34;&#34;Get the value for the given metric.

        Args:
            metric (str): The metric name.
            use_mean (bool, optional): Whether to compute the metric over the population or just the elite. Defaults to `True`.
            population (str, optional): Which population to compute the metric on. Defaults to `&#39;feasible&#39;`.

        Raises:
            NotImplementedError: Raised if the metric is not recognized.

        Returns:
            float: The value of the metric.
        &#34;&#34;&#34;
        op = np.mean if use_mean else np.max
        pop = self._feasible if population == &#39;feasible&#39; else self._infeasible
        if metric == &#39;fitness&#39;:
            return op([cs.c_fitness for cs in pop]) if len(pop) &gt; 0 else 0.
        elif metric == &#39;age&#39;:
            return op([cs.age for cs in pop]) if len(pop) &gt; 0 else 0.
        elif metric == &#39;size&#39;:
            return len(pop)
        else:
            raise NotImplementedError(f&#39;Unrecognized metric {metric}&#39;)

    def get_elite(self,
                  population: str = &#39;feasible&#39;,
                  always_max: bool = True) -&gt; Optional[CandidateSolution]:
        &#34;&#34;&#34;Get the elite of the selected population.

        Args:
            population (str, optional): The population. Defaults to `&#39;feasible&#39;`.
            always_max (bool): Whether to select based on highest fitness. Defaults to `True`.

        Returns:
            Optional[CandidateSolution]: The elite solution, if it exists.
        &#34;&#34;&#34;
        pop = self._feasible if population == &#39;feasible&#39; else self._infeasible
        if pop:
            get_max = always_max or population == &#39;feasible&#39;
            return sorted(pop, key=lambda x: x.c_fitness, reverse=get_max)[0]
        else:
            return None

    def toggle_module_mutability(self,
                                 module: str):
        &#34;&#34;&#34;Toggle the mutability of a given module for all solutions in the bin.

        Args:
            module (str): The module name.
        &#34;&#34;&#34;
        for pop in [self._feasible, self._infeasible]:
            for cs in pop:
                cs.hls_mod[module][&#39;mutable&#39;] = not cs.hls_mod[module][&#39;mutable&#39;]
    
    def to_json(self) -&gt; Dict[str, Any]:
        return {
            &#39;feasible&#39;: [cs.to_json() for cs in self._feasible],
            &#39;infeasible&#39;: [cs.to_json() for cs in self._infeasible],
            &#39;bin_idx&#39;: list(self.bin_idx),
            &#39;bin_size&#39;: list(self.bin_size)
        }

    @staticmethod
    def from_json(my_args: Dict[str, Any]) -&gt; &#39;MAPBin&#39;:
        mb = MAPBin(bin_idx=tuple(my_args[&#39;bin_idx&#39;]),
                    bin_size=tuple(my_args[&#39;bin_size&#39;]))
        mb._feasible = [CandidateSolution.from_json(
            cs) for cs in my_args[&#39;feasible&#39;]]
        mb._infeasible = [CandidateSolution.from_json(
            cs) for cs in my_args[&#39;infeasible&#39;]]
        return mb</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pcgsepy.mapelites.bin.MAPBin"><code class="flex name class">
<span>class <span class="ident">MAPBin</span></span>
<span>(</span><span>bin_idx: Tuple[int, int], bin_size: Tuple[float, float], bin_initial_size: Optional[Tuple[float, float]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a 2D bin object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bin_idx</code></strong> :&ensp;<code>Tuple[int, int]</code></dt>
<dd>The index of the bin in the grid.</dd>
<dt><strong><code>bin_size</code></strong> :&ensp;<code>Tuple[float, float]</code></dt>
<dd>The size of the bin.</dd>
<dt><strong><code>bin_initial_size</code></strong></dt>
<dd>Optional[Tuple[float, float]]: Initial size of the bin. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MAPBin:
    __slots__ = [&#39;_feasible&#39;, &#39;_infeasible&#39;, &#39;bin_idx&#39;, &#39;bin_size&#39;, &#39;bin_initial_size&#39;, &#39;new_elite&#39;]

    def __init__(self,
                 bin_idx: Tuple[int, int],
                 bin_size: Tuple[float, float],
                 bin_initial_size: Optional[Tuple[float, float]] = None):
        &#34;&#34;&#34;Create a 2D bin object.

        Args:
            bin_idx (Tuple[int, int]): The index of the bin in the grid.
            bin_size (Tuple[float, float]): The size of the bin.
            bin_initial_size: Optional[Tuple[float, float]]: Initial size of the bin. Defaults to None.
        &#34;&#34;&#34;
        self._feasible = []
        self._infeasible = []
        self.bin_idx = bin_idx
        self.bin_size = bin_size
        self.bin_initial_size = bin_initial_size if bin_initial_size else bin_size
        self.new_elite = {&#39;feasible&#39;: False,
                          &#39;_elite_feasible&#39;: None,
                          &#39;infeasible&#39;: False,
                          &#39;_elite_infeasible&#39;: None}

    def __str__(self) -&gt; str:
        return f&#39;Bin {self.bin_idx}, {self.bin_size} w/ {len(self._feasible)}f and {len(self._infeasible)}i cs&#39;

    def __repr__(self) -&gt; str:
        return str(self)
    
    @property
    def subdividable(self) -&gt; bool:
        &#34;&#34;&#34;Check if the bin can be subdivided. Use this method when locally increasing resolution of the behavioral map.

        Returns:
            bool: Whether the bin can be subdivided.
        &#34;&#34;&#34;
        bs0, bs1 = self.bin_size
        bis0, bis1 = self.bin_initial_size
        ms0 = bis0 * BIN_SMALLEST_PERC
        ms1 = bis1 * BIN_SMALLEST_PERC
        bs0 /= 2
        bs1 /= 2
        return bs0 &gt;= ms0 and bs1 &gt;= ms1
        
    def non_empty(self,
                  pop: str) -&gt; bool:
        &#34;&#34;&#34;Check if the bin is not empty for the given population.

        Args:
            pop (str): The population to check for.

        Returns:
            bool: Whether the bin is empty.
        &#34;&#34;&#34;
        return len(self._feasible if pop == &#39;feasible&#39; else self._infeasible) &gt; 0

    def _reduce_pop(self,
                    pop: List[CandidateSolution]) -&gt; List[CandidateSolution]:
        &#34;&#34;&#34;Cull the population within this bin.

        Args:
            pop (List[CandidateSolution]): The population.

        Returns:
            List[CandidateSolution]: The culled population.
        &#34;&#34;&#34;
        if len(pop) &gt; BIN_POP_SIZE:
            pop.sort(key=lambda x: x.c_fitness, reverse=True)
            pop = pop[:BIN_POP_SIZE]
        return pop

    def insert_cs(self,
                  cs: CandidateSolution):
        &#34;&#34;&#34;Add a solution in the bin.

        Args:
            cs (CandidateSolution): The solution to add.
        &#34;&#34;&#34;
        if cs.is_feasible:
            if cs not in self._feasible:
                self._feasible.append(cs)
                self._feasible = self._reduce_pop(self._feasible)
        else:
            if cs not in self._infeasible:
                self._infeasible.append(cs)
                self._infeasible = self._reduce_pop(self._infeasible)

    def check_new_elite(self,
                        pop: str = &#39;feasible&#39;):
        &#34;&#34;&#34;Check if the bin contains a new elite for the selected population.

        Args:
            pop (str, optional): The population. Defaults to &#39;feasible&#39;.
        &#34;&#34;&#34;
        checking = f&#39;_elite_{pop}&#39;
        elite = self.get_elite(population=pop)
        if elite is not None and (self.new_elite[checking] is None or elite.string != self.new_elite[checking].string):
            self.new_elite[pop] = True
            self.new_elite[checking] = elite
            for cs in self._feasible if pop == &#39;feasible&#39; else self._infeasible:
                if cs.string != elite.string:
                    cs._content = None
    
    def age(self,
            diff: int = -1):
        &#34;&#34;&#34;Age the bin.

        Args:
            diff (int, optional): Value used to modify the bin&#39;s age. Defaults to `-1`.
        &#34;&#34;&#34;
        for pop in [self._feasible, self._infeasible]:
            for cs in pop:
                cs.age += diff

    def remove_old(self):
        &#34;&#34;&#34;Remove old solutions. Old solutions are solutions with an age `&lt;=0`.&#34;&#34;&#34;
        to_rem_f = [x for x in self._feasible if x.age &lt;= 0]
        for cs in to_rem_f:
            self._feasible.remove(cs)
        to_rem_i = [x for x in self._infeasible if x.age &lt;= 0]
        for cs in to_rem_i:
            self._infeasible.remove(cs)

    def get_metric(self,
                   metric: str,
                   use_mean: bool = True,
                   population: str = &#39;feasible&#39;) -&gt; float:
        &#34;&#34;&#34;Get the value for the given metric.

        Args:
            metric (str): The metric name.
            use_mean (bool, optional): Whether to compute the metric over the population or just the elite. Defaults to `True`.
            population (str, optional): Which population to compute the metric on. Defaults to `&#39;feasible&#39;`.

        Raises:
            NotImplementedError: Raised if the metric is not recognized.

        Returns:
            float: The value of the metric.
        &#34;&#34;&#34;
        op = np.mean if use_mean else np.max
        pop = self._feasible if population == &#39;feasible&#39; else self._infeasible
        if metric == &#39;fitness&#39;:
            return op([cs.c_fitness for cs in pop]) if len(pop) &gt; 0 else 0.
        elif metric == &#39;age&#39;:
            return op([cs.age for cs in pop]) if len(pop) &gt; 0 else 0.
        elif metric == &#39;size&#39;:
            return len(pop)
        else:
            raise NotImplementedError(f&#39;Unrecognized metric {metric}&#39;)

    def get_elite(self,
                  population: str = &#39;feasible&#39;,
                  always_max: bool = True) -&gt; Optional[CandidateSolution]:
        &#34;&#34;&#34;Get the elite of the selected population.

        Args:
            population (str, optional): The population. Defaults to `&#39;feasible&#39;`.
            always_max (bool): Whether to select based on highest fitness. Defaults to `True`.

        Returns:
            Optional[CandidateSolution]: The elite solution, if it exists.
        &#34;&#34;&#34;
        pop = self._feasible if population == &#39;feasible&#39; else self._infeasible
        if pop:
            get_max = always_max or population == &#39;feasible&#39;
            return sorted(pop, key=lambda x: x.c_fitness, reverse=get_max)[0]
        else:
            return None

    def toggle_module_mutability(self,
                                 module: str):
        &#34;&#34;&#34;Toggle the mutability of a given module for all solutions in the bin.

        Args:
            module (str): The module name.
        &#34;&#34;&#34;
        for pop in [self._feasible, self._infeasible]:
            for cs in pop:
                cs.hls_mod[module][&#39;mutable&#39;] = not cs.hls_mod[module][&#39;mutable&#39;]
    
    def to_json(self) -&gt; Dict[str, Any]:
        return {
            &#39;feasible&#39;: [cs.to_json() for cs in self._feasible],
            &#39;infeasible&#39;: [cs.to_json() for cs in self._infeasible],
            &#39;bin_idx&#39;: list(self.bin_idx),
            &#39;bin_size&#39;: list(self.bin_size)
        }

    @staticmethod
    def from_json(my_args: Dict[str, Any]) -&gt; &#39;MAPBin&#39;:
        mb = MAPBin(bin_idx=tuple(my_args[&#39;bin_idx&#39;]),
                    bin_size=tuple(my_args[&#39;bin_size&#39;]))
        mb._feasible = [CandidateSolution.from_json(
            cs) for cs in my_args[&#39;feasible&#39;]]
        mb._infeasible = [CandidateSolution.from_json(
            cs) for cs in my_args[&#39;infeasible&#39;]]
        return mb</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pcgsepy.mapelites.bin.MAPBin.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>my_args: Dict[str, Any]) ‑> <a title="pcgsepy.mapelites.bin.MAPBin" href="#pcgsepy.mapelites.bin.MAPBin">MAPBin</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(my_args: Dict[str, Any]) -&gt; &#39;MAPBin&#39;:
    mb = MAPBin(bin_idx=tuple(my_args[&#39;bin_idx&#39;]),
                bin_size=tuple(my_args[&#39;bin_size&#39;]))
    mb._feasible = [CandidateSolution.from_json(
        cs) for cs in my_args[&#39;feasible&#39;]]
    mb._infeasible = [CandidateSolution.from_json(
        cs) for cs in my_args[&#39;infeasible&#39;]]
    return mb</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pcgsepy.mapelites.bin.MAPBin.bin_idx"><code class="name">var <span class="ident">bin_idx</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pcgsepy.mapelites.bin.MAPBin.bin_initial_size"><code class="name">var <span class="ident">bin_initial_size</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pcgsepy.mapelites.bin.MAPBin.bin_size"><code class="name">var <span class="ident">bin_size</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pcgsepy.mapelites.bin.MAPBin.new_elite"><code class="name">var <span class="ident">new_elite</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pcgsepy.mapelites.bin.MAPBin.subdividable"><code class="name">var <span class="ident">subdividable</span> : bool</code></dt>
<dd>
<div class="desc"><p>Check if the bin can be subdivided. Use this method when locally increasing resolution of the behavioral map.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Whether the bin can be subdivided.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def subdividable(self) -&gt; bool:
    &#34;&#34;&#34;Check if the bin can be subdivided. Use this method when locally increasing resolution of the behavioral map.

    Returns:
        bool: Whether the bin can be subdivided.
    &#34;&#34;&#34;
    bs0, bs1 = self.bin_size
    bis0, bis1 = self.bin_initial_size
    ms0 = bis0 * BIN_SMALLEST_PERC
    ms1 = bis1 * BIN_SMALLEST_PERC
    bs0 /= 2
    bs1 /= 2
    return bs0 &gt;= ms0 and bs1 &gt;= ms1</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pcgsepy.mapelites.bin.MAPBin.age"><code class="name flex">
<span>def <span class="ident">age</span></span>(<span>self, diff: int = -1)</span>
</code></dt>
<dd>
<div class="desc"><p>Age the bin.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>diff</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Value used to modify the bin's age. Defaults to <code>-1</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def age(self,
        diff: int = -1):
    &#34;&#34;&#34;Age the bin.

    Args:
        diff (int, optional): Value used to modify the bin&#39;s age. Defaults to `-1`.
    &#34;&#34;&#34;
    for pop in [self._feasible, self._infeasible]:
        for cs in pop:
            cs.age += diff</code></pre>
</details>
</dd>
<dt id="pcgsepy.mapelites.bin.MAPBin.check_new_elite"><code class="name flex">
<span>def <span class="ident">check_new_elite</span></span>(<span>self, pop: str = 'feasible')</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the bin contains a new elite for the selected population.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pop</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The population. Defaults to 'feasible'.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_new_elite(self,
                    pop: str = &#39;feasible&#39;):
    &#34;&#34;&#34;Check if the bin contains a new elite for the selected population.

    Args:
        pop (str, optional): The population. Defaults to &#39;feasible&#39;.
    &#34;&#34;&#34;
    checking = f&#39;_elite_{pop}&#39;
    elite = self.get_elite(population=pop)
    if elite is not None and (self.new_elite[checking] is None or elite.string != self.new_elite[checking].string):
        self.new_elite[pop] = True
        self.new_elite[checking] = elite
        for cs in self._feasible if pop == &#39;feasible&#39; else self._infeasible:
            if cs.string != elite.string:
                cs._content = None</code></pre>
</details>
</dd>
<dt id="pcgsepy.mapelites.bin.MAPBin.get_elite"><code class="name flex">
<span>def <span class="ident">get_elite</span></span>(<span>self, population: str = 'feasible', always_max: bool = True) ‑> Optional[<a title="pcgsepy.lsystem.solution.CandidateSolution" href="../lsystem/solution.html#pcgsepy.lsystem.solution.CandidateSolution">CandidateSolution</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the elite of the selected population.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>population</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The population. Defaults to <code>'feasible'</code>.</dd>
<dt><strong><code>always_max</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to select based on highest fitness. Defaults to <code>True</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[CandidateSolution]</code></dt>
<dd>The elite solution, if it exists.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elite(self,
              population: str = &#39;feasible&#39;,
              always_max: bool = True) -&gt; Optional[CandidateSolution]:
    &#34;&#34;&#34;Get the elite of the selected population.

    Args:
        population (str, optional): The population. Defaults to `&#39;feasible&#39;`.
        always_max (bool): Whether to select based on highest fitness. Defaults to `True`.

    Returns:
        Optional[CandidateSolution]: The elite solution, if it exists.
    &#34;&#34;&#34;
    pop = self._feasible if population == &#39;feasible&#39; else self._infeasible
    if pop:
        get_max = always_max or population == &#39;feasible&#39;
        return sorted(pop, key=lambda x: x.c_fitness, reverse=get_max)[0]
    else:
        return None</code></pre>
</details>
</dd>
<dt id="pcgsepy.mapelites.bin.MAPBin.get_metric"><code class="name flex">
<span>def <span class="ident">get_metric</span></span>(<span>self, metric: str, use_mean: bool = True, population: str = 'feasible') ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Get the value for the given metric.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>metric</code></strong> :&ensp;<code>str</code></dt>
<dd>The metric name.</dd>
<dt><strong><code>use_mean</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to compute the metric over the population or just the elite. Defaults to <code>True</code>.</dd>
<dt><strong><code>population</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Which population to compute the metric on. Defaults to <code>'feasible'</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotImplementedError</code></dt>
<dd>Raised if the metric is not recognized.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The value of the metric.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_metric(self,
               metric: str,
               use_mean: bool = True,
               population: str = &#39;feasible&#39;) -&gt; float:
    &#34;&#34;&#34;Get the value for the given metric.

    Args:
        metric (str): The metric name.
        use_mean (bool, optional): Whether to compute the metric over the population or just the elite. Defaults to `True`.
        population (str, optional): Which population to compute the metric on. Defaults to `&#39;feasible&#39;`.

    Raises:
        NotImplementedError: Raised if the metric is not recognized.

    Returns:
        float: The value of the metric.
    &#34;&#34;&#34;
    op = np.mean if use_mean else np.max
    pop = self._feasible if population == &#39;feasible&#39; else self._infeasible
    if metric == &#39;fitness&#39;:
        return op([cs.c_fitness for cs in pop]) if len(pop) &gt; 0 else 0.
    elif metric == &#39;age&#39;:
        return op([cs.age for cs in pop]) if len(pop) &gt; 0 else 0.
    elif metric == &#39;size&#39;:
        return len(pop)
    else:
        raise NotImplementedError(f&#39;Unrecognized metric {metric}&#39;)</code></pre>
</details>
</dd>
<dt id="pcgsepy.mapelites.bin.MAPBin.insert_cs"><code class="name flex">
<span>def <span class="ident">insert_cs</span></span>(<span>self, cs: <a title="pcgsepy.lsystem.solution.CandidateSolution" href="../lsystem/solution.html#pcgsepy.lsystem.solution.CandidateSolution">CandidateSolution</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a solution in the bin.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cs</code></strong> :&ensp;<code>CandidateSolution</code></dt>
<dd>The solution to add.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_cs(self,
              cs: CandidateSolution):
    &#34;&#34;&#34;Add a solution in the bin.

    Args:
        cs (CandidateSolution): The solution to add.
    &#34;&#34;&#34;
    if cs.is_feasible:
        if cs not in self._feasible:
            self._feasible.append(cs)
            self._feasible = self._reduce_pop(self._feasible)
    else:
        if cs not in self._infeasible:
            self._infeasible.append(cs)
            self._infeasible = self._reduce_pop(self._infeasible)</code></pre>
</details>
</dd>
<dt id="pcgsepy.mapelites.bin.MAPBin.non_empty"><code class="name flex">
<span>def <span class="ident">non_empty</span></span>(<span>self, pop: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the bin is not empty for the given population.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pop</code></strong> :&ensp;<code>str</code></dt>
<dd>The population to check for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Whether the bin is empty.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def non_empty(self,
              pop: str) -&gt; bool:
    &#34;&#34;&#34;Check if the bin is not empty for the given population.

    Args:
        pop (str): The population to check for.

    Returns:
        bool: Whether the bin is empty.
    &#34;&#34;&#34;
    return len(self._feasible if pop == &#39;feasible&#39; else self._infeasible) &gt; 0</code></pre>
</details>
</dd>
<dt id="pcgsepy.mapelites.bin.MAPBin.remove_old"><code class="name flex">
<span>def <span class="ident">remove_old</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove old solutions. Old solutions are solutions with an age <code>&lt;=0</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_old(self):
    &#34;&#34;&#34;Remove old solutions. Old solutions are solutions with an age `&lt;=0`.&#34;&#34;&#34;
    to_rem_f = [x for x in self._feasible if x.age &lt;= 0]
    for cs in to_rem_f:
        self._feasible.remove(cs)
    to_rem_i = [x for x in self._infeasible if x.age &lt;= 0]
    for cs in to_rem_i:
        self._infeasible.remove(cs)</code></pre>
</details>
</dd>
<dt id="pcgsepy.mapelites.bin.MAPBin.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> Dict[str, Any]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; Dict[str, Any]:
    return {
        &#39;feasible&#39;: [cs.to_json() for cs in self._feasible],
        &#39;infeasible&#39;: [cs.to_json() for cs in self._infeasible],
        &#39;bin_idx&#39;: list(self.bin_idx),
        &#39;bin_size&#39;: list(self.bin_size)
    }</code></pre>
</details>
</dd>
<dt id="pcgsepy.mapelites.bin.MAPBin.toggle_module_mutability"><code class="name flex">
<span>def <span class="ident">toggle_module_mutability</span></span>(<span>self, module: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Toggle the mutability of a given module for all solutions in the bin.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>module</code></strong> :&ensp;<code>str</code></dt>
<dd>The module name.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_module_mutability(self,
                             module: str):
    &#34;&#34;&#34;Toggle the mutability of a given module for all solutions in the bin.

    Args:
        module (str): The module name.
    &#34;&#34;&#34;
    for pop in [self._feasible, self._infeasible]:
        for cs in pop:
            cs.hls_mod[module][&#39;mutable&#39;] = not cs.hls_mod[module][&#39;mutable&#39;]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pcgsepy.mapelites" href="index.html">pcgsepy.mapelites</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pcgsepy.mapelites.bin.MAPBin" href="#pcgsepy.mapelites.bin.MAPBin">MAPBin</a></code></h4>
<ul class="">
<li><code><a title="pcgsepy.mapelites.bin.MAPBin.age" href="#pcgsepy.mapelites.bin.MAPBin.age">age</a></code></li>
<li><code><a title="pcgsepy.mapelites.bin.MAPBin.bin_idx" href="#pcgsepy.mapelites.bin.MAPBin.bin_idx">bin_idx</a></code></li>
<li><code><a title="pcgsepy.mapelites.bin.MAPBin.bin_initial_size" href="#pcgsepy.mapelites.bin.MAPBin.bin_initial_size">bin_initial_size</a></code></li>
<li><code><a title="pcgsepy.mapelites.bin.MAPBin.bin_size" href="#pcgsepy.mapelites.bin.MAPBin.bin_size">bin_size</a></code></li>
<li><code><a title="pcgsepy.mapelites.bin.MAPBin.check_new_elite" href="#pcgsepy.mapelites.bin.MAPBin.check_new_elite">check_new_elite</a></code></li>
<li><code><a title="pcgsepy.mapelites.bin.MAPBin.from_json" href="#pcgsepy.mapelites.bin.MAPBin.from_json">from_json</a></code></li>
<li><code><a title="pcgsepy.mapelites.bin.MAPBin.get_elite" href="#pcgsepy.mapelites.bin.MAPBin.get_elite">get_elite</a></code></li>
<li><code><a title="pcgsepy.mapelites.bin.MAPBin.get_metric" href="#pcgsepy.mapelites.bin.MAPBin.get_metric">get_metric</a></code></li>
<li><code><a title="pcgsepy.mapelites.bin.MAPBin.insert_cs" href="#pcgsepy.mapelites.bin.MAPBin.insert_cs">insert_cs</a></code></li>
<li><code><a title="pcgsepy.mapelites.bin.MAPBin.new_elite" href="#pcgsepy.mapelites.bin.MAPBin.new_elite">new_elite</a></code></li>
<li><code><a title="pcgsepy.mapelites.bin.MAPBin.non_empty" href="#pcgsepy.mapelites.bin.MAPBin.non_empty">non_empty</a></code></li>
<li><code><a title="pcgsepy.mapelites.bin.MAPBin.remove_old" href="#pcgsepy.mapelites.bin.MAPBin.remove_old">remove_old</a></code></li>
<li><code><a title="pcgsepy.mapelites.bin.MAPBin.subdividable" href="#pcgsepy.mapelites.bin.MAPBin.subdividable">subdividable</a></code></li>
<li><code><a title="pcgsepy.mapelites.bin.MAPBin.to_json" href="#pcgsepy.mapelites.bin.MAPBin.to_json">to_json</a></code></li>
<li><code><a title="pcgsepy.mapelites.bin.MAPBin.toggle_module_mutability" href="#pcgsepy.mapelites.bin.MAPBin.toggle_module_mutability">toggle_module_mutability</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>